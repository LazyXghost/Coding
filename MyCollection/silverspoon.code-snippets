{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Main tempelate for c++ code": {
		"prefix": "silverspoon-minimal",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define FASTIO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)",
			"#define val(x) (*(x))",
			"typedef long long ll;",
			"",
			"struct solution{",
			"    ll n;",
			"    vector<ll> arr;",
			"    solution(){",
			"        cin>>n;",
			"        for(ll i = 0;i<n;i++){",
			"            ll x;",
			"            cin>>x;",
			"            arr.push_back(x);",
			"        }",
			"        $0",
			"    }",
			"};",
			"int main()",
			"{",
			"    #ifndef ONLINE_JUDGE",
			"    freopen(\"Input.txt\", \"r\", stdin);",
			"    freopen(\"Output.txt\", \"w\", stdout);",
			"    freopen(\"Debug.txt\", \"w\", stderr);",
			"    #endif",
			"    FASTIO;",
			"    ll t; cin >> t; while(t--){",
			"        solution sol;",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "FASTIO, val, debugger",
		"scope": "cpp"
	},
	"Second tempelate for c++ code": {
		"prefix": "silverspoon-maximal",
		"body": [
			"#define pqmax(a) priority_queue<a, vector<a>>",
			"#define pqmin(a) priority_queue<a, vector<a>, greater<a>>",
			"#define pqcustom(a) priority_queue<a, vector<a>, pqComp>",
			"#define fill(start, end, val) fill(start, end, val)",
			"#define fill(start, end, val) fill(start, end, val)",
			"#define removeScientific cout<<fixed;",
			"#define precision(a) cout<<setprecision(a);",
			"#define set_bits __builtin_popcountll",
			"#define INF INFINITY",
			"const long long MOD = 1e9 + 7;",
			"const long double pi = 3.14159265358979323846;",
			"// by default priority queue is made max heap, to use min heap use greater or make custom comparator",
			"// priority_queue<long long> - creates max heap",
			"// priority_queue<pair<long long,long long>> - ORDERING BY FIRST ELEMENT(if first elements are same then ordering by second elements)",
			"// priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,{COMPARATOR}>",
			"",
			"$0",
		],
		"description": "Priority Queue, fill, remove Scientific, setBitCount, MOD, INF, pi",
		"scope": "cpp"
	},
	"Comparators tempelate for complex c++ code": {
		"prefix": "silverspoon-comparatorsAndPower",
		"body": [
			"bool vComp(pair<ll, ll> a, pair<ll, ll> b)",
			"{",
            "    return a.first < b.first; // increasing order",
            "    // return a.first > b.first; // decreasing order",
			"}",
			"struct pqComp {",
			"    constexpr bool operator()(",
			"        pair<ll, ll> const& a,",
			"        pair<ll, ll> const& b)",
			"        const noexcept",
			"    {",
			"        return a.second < b.second; //max heap",
			"        // return a.second > b.second; //min heap",
			"    }",
			"};",
			"long long power(long long x,long long y){",
			"    long long res = 1;",
			"    while(y>0){",
			"        if(y&1)",
			"            res=(res*x);",
			"            // res=(res*x)%MOD;",
			"        y = y>>1;",
			"        x = x*x;",
			"        // x = (x*x)%MOD;",
			"    }",
			"    return res;",
			"}",
		],
		"description": "Vector comparator, priority queue comparator, power",
		"scope": "cpp"
	},
	"Max Segment Tree data structure tempelate": {
		"prefix": "silverspoon-segmentTree",
		"body": [
			"template <typename stNode>",
			"class SEGMENT_TREE",
			"{",
			"protected:",
			"    stNode neutralElement;",
			"    virtual stNode leafElement(ll v) {}",
			"    virtual stNode operation(stNode a, stNode b) {}",
			"",
			"    ll size;",
			"    vector<stNode> tree;",
			"    void build(vector<ll> &a, ll x, ll lx, ll rx)",
			"    {",
			"        if (rx - lx == 1)",
			"        {",
			"            if (lx < (ll)a.size())",
			"            {",
			"                tree[x] = leafElement(a[lx]);",
			"            }",
			"            return;",
			"        }",
			"        ll m = (lx + rx) / 2;",
			"        build(a, 2 * x + 1, lx, m);",
			"        build(a, 2 * x + 2, m, rx);",
			"",
			"        tree[x] = operation(tree[2 * x + 1], tree[2 * x + 2]);",
			"    }",
			"",
			"    void set(ll i, ll v, ll x, ll lx, ll rx)",
			"    {",
			"        if (rx - lx == 1)",
			"        {",
			"            tree[x] = leafElement(v);",
			"            return;",
			"        }",
			"",
			"        ll m = (lx + rx) / 2;",
			"        if (i < m)",
			"        {",
			"            set(i, v, 2 * x + 1, lx, m);",
			"        }",
			"        else",
			"        {",
			"            set(i, v, 2 * x + 2, m, rx);",
			"        }",
			"",
			"        tree[x] = operation(tree[2 * x + 1], tree[2 * x + 2]);",
			"    }",
			"",
			"    stNode query(ll l, ll r, ll x, ll lx, ll rx)",
			"    {",
			"        if (lx >= r || l >= rx)",
			"            return neutralElement;",
			"        if (lx >= l && rx <= r)",
			"            return tree[x];",
			"        ll m = (lx + rx) / 2;",
			"        stNode lstq = query(l, r, 2 * x + 1, lx, m);",
			"        stNode rstq = query(l, r, 2 * x + 2, m, rx);",
			"        return operation(lstq, rstq);",
			"    }",
			"",
			"public:",
			"    void build(vector<ll> &a)",
			"    {",
			"        build(a, 0, 0, size);",
			"    }",
			"",
			"    void set(ll i, ll v)",
			"    {",
			"        set(i, v, 0, 0, size);",
			"    }",
			"",
			"    stNode query(ll l, ll r)",
			"    {",
			"        return query(l, r, 0, 0, size);",
			"    }",
			"",
			"    SEGMENT_TREE(ll n, stNode neutralValue)",
			"    {",
			"        neutralElement = neutralValue;",
			"        size = 1;",
			"        while (size < n)",
			"            size *= 2;",
			"        tree.resize(2 * size, neutralElement);",
			"    }",
			"};",
			"",
			"struct myStNode",
			"{",
			"    ll min, count;",
			"};",
			"class MY_SEGMENT_TREE : public SEGMENT_TREE<myStNode>",
			"{",
			"    /*",
			"     * You need to implement myStNode, leafElement, operation",
			"     */",
			"    myStNode leafElement(ll v) override",
			"    {",
			"        /*",
			"         * leafElement defines the value that should be placed at leaf node of tree, if the value v is present in array",
			"         */",
			"        return {v, 1};",
			"    }",
			"    myStNode operation(myStNode a, myStNode b) override",
			"    {",
			"        /*",
			"         * Operation defines how to build the segment tree",
			"         */",
			"        if (a.min < b.min)",
			"            return a;",
			"        if (a.min > b.min)",
			"            return b;",
			"        return {a.min, a.count + b.count};",
			"    }",
			"",
			"public:",
			"    MY_SEGMENT_TREE(ll n, myStNode neutralValue) : SEGMENT_TREE(n, neutralValue) {",
			"        /*",
			"         * Neutral value is the one that will be present at extra nodes",
			"         * If array of size 6, then end nodes are 7th and 8th",
			"         * Neutral value will fill the leaf nodes - 7,8",
			"         */",
			"    }",
			"};",
			"// Usage -: MY_SEGMENT_TREE myST(<size>, <neutralValue>);",
			"// Example -: MY_SEGMENT_TREE minST(6, {LLONG_MAX, 0});",
			"$0",
		],
		"description": "MaxSegmentTree data structure",
		"scope": "cpp"
	},
	"Disjoint set union data structures tempelate": {
		"prefix": "silverspoon-DSU",
		"body": [
			"// ============================= DSU ================================",
			"",
			"class dsu",
			"{",
			"    map<int,int> parent, size;",
			"",
			"public:",
			"    // making new set by just initialising the parent of set as the same number",
			"    void make_set(int v)",
			"    {",
			"        parent[v] = v;",
			"        size[v] = 1;",
			"    }",
			"",
			"    // finding the root of the set",
			"    int find_set(int v)",
			"    {",
			"        if (v == parent[v])",
			"            return v;",
			"        // return find_set(parent[v]);",
			"",
			"        return parent[v] = find_set(parent[v]);",
			"        // 1st optimisization - path compression",
			"        // directly connects all the linear chain nodes to parent",
			"        // 7->5->3->1 ==> 7->1,5->1,3->1",
			"    }",
			"",
			"    // making the root of one set as the parent of root of other set will combine two sets",
			"    void union_set(int a, int b)",
			"    {",
			"        a = find_set(a);",
			"        b = find_set(b);",
			"        if (a != b)",
			"        {",
			"            // 2nd optimisation - union by size",
			"            if (size[a] < size[b])",
			"                swap(a, b);",
			"",
			"            parent[b] = a;",
			"            size[a] += size[b];",
			"        }",
			"    }",
			"",
			"    // returning the size of the set of vertex v",
			"    int find_size(int v)",
			"    {",
			"        return size[find_set(v)];",
			"    }",
			"};",
			"/*",
			"Time complexity -",
			"                            AFTER OPTIMISATION'S",
			"    FIND SET  - O(n)      O(alpha(n)) - almost constant",
			"    MAKE SET  - O(1)              O(1)",
			"    UNION SET - O(n)           O(alpha(n))",
			"*/",
			"//==================================================================",
			"$0",
		],
		"description": "DSU structure",
		"scope": "cpp"
	},
	"Policy based data structures tempelate": {
		"prefix": "silverspoon-pbds_multiset",
		"body": [
			"// ---------------------------------Policy Based DataStructures----------------------",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"", 
			"// defining template when all elements are distinct",
			"// oset<int> arr;",
			"template <class T> using oset = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"",
			"// defining template when duplicate elements are also used",
			"// omulset<int> arr;",
			"template <class T> using omulset = tree<T, null_type, less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"", 
			"//  .find_by_order(x) : index of the x element in the set starting from 0",
			"//  .order_of_key(x)  : number of elements strictly smaller than x in the set",
			"// --------------------------------",
			"$0",
		],
		"description": "Policy based data structure",
		"scope": "cpp"
	},
	"Debugger template": {
		"prefix": "silverspoon-debugger",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(int t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"void _print(double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"(\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \")\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(vector <vector <T>> v){cerr << \" => \\n[\\n\"; for (vector<T> i : v) {cerr<<\"  \";_print(i); cerr << endl;} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"{ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"}\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"{ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"}\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {cerr<< \"(\";_print(i.first); cerr << \"--> \"; _print(i.second);cerr<< \"),\";} cerr << \"]\";}",
			"template <class T, class V> void _print(unordered_map <T, V> v) {cerr << \"[ \"; for (auto i : v) {cerr<< \"(\";_print(i.first); cerr << \"--> \"; _print(i.second);cerr<< \"),\";} cerr << \"]\";}",
			"",
		],
		"description": "Debugger for cpp",
		"scope": "cpp"
	}
}
